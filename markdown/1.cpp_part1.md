## Page 1

![Page 1](1.cpp_part1_page_1.png)

[CSE221 Data Structures]
Lecture 1: C++ and Object-Oriented Programming
Taesik Gong
taesik.gong@ unist.ac.kr
1


## Page 2

![Page 2](1.cpp_part1_page_2.png)

Goals of This Lecture
• Overview of C++ language
✓At a glance, C++ = C + Class
• Intro to object-oriented programming (OOP)
✓In structured programming, program = a series of functions
✓In OOP, program = interaction between objects
✓OOP encourages abstraction 
Effective in representing a complex problem 
✓OOP encourages software reuse
Easily reuse classes and their implementation 
2


## Page 3

![Page 3](1.cpp_part1_page_3.png)

Important Assumption
• This course assumes that you are already familiar with C++
✓Prerequisite: CSE241 Advanced Programming
• This lecture is a quick overview (or recap) of important 
concepts of C++ in the context of data structure
✓Basically, it’s impossible to teach all C++ knowledge within 2-3 lectures
• If you are new to C++, the initial lectures might be challenging
✓Please spend additional time reviewing the lecture notes and writing C++ 
codes in them
3


## Page 4

![Page 4](1.cpp_part1_page_4.png)

Object-Oriented 
Programming
4


## Page 5

![Page 5](1.cpp_part1_page_5.png)

The C++ Programming Model
5
CoolProgram.cpp
Library Functions
Compiler
a.out
User


## Page 6

![Page 6](1.cpp_part1_page_6.png)

A Simple C++ Program
•  Two integer inputs x and y
•  Output their sum
6
#include <cstdlib>
#include <iostream>
/* This program inputs two numbers x and y and outputs their sum */
int main( ) {
     int x, y;
     std::cout << “please enter two numbers: ”
     std::cin >> x >> y; 
 
// input x and y
     int sum = x + y; 
 
 
// compute their sum
     std::cout << “Their sum is ” << sum << std::endl;
     return EXIT_SUCCESS  
// terminate successfully
}


## Page 7

![Page 7](1.cpp_part1_page_7.png)

Abstraction and Abstract Data Type
• Abstraction: simplifying complex ideas by focusing on their 
essential properties and operations, while hiding the 
implementation details 
• Abstraction depends on what to focus
✓Procedure abstraction: focuses on operations
✓Data abstraction: data + operations as one
✓Object abstraction: data abstraction + reusable sub types (class)
• Abstract data type (ADT)
✓
 Definition of a set of data + associated operations 
• Implementation of ADT 
✓Data → data structure 
Stack, Queue, Tree etc.
✓Operations → manipulation of data structure
Stack: push, pop etc.
✓Error conditions associated with operations
7


## Page 8

![Page 8](1.cpp_part1_page_8.png)

Example of Abstract Data Type (ADT)
• Example: ADT modeling of a simple stock trading system
✓The data stored are buy/sell orders
✓The operations supported are
order buy(stock, shares, price)
order sell(stock, shares, price)
void cancel(order)
✓Error conditions:
Buy/sell a nonexistent stock
Cancel a nonexistent order
8


## Page 9

![Page 9](1.cpp_part1_page_9.png)

C & C++ in Abstraction View
• C supports Procedure-Oriented programming
✓Procedure (function) + data structure
Procedure (function) manipulates data
• C++ supports Object-Oriented programming
✓Object-oriented programming (OOP) is a programming 
paradigm that uses objects and their interactions to 
design applications and computer programs. 
✓Data abstract + reusable subtypes with following features
Encapsulation, Polymorphism, Inheritance
9


## Page 10

![Page 10](1.cpp_part1_page_10.png)

Procedural-Oriented VS. Object-Oriented 
10
Procedural-Oriented Program
main
data
function-1
(procedure)
data
function-2
(procedure)
data
function-3
(procedure)
data
Object-Oriented Program
Object-1
data-1
+
functions
Object-2
Object-3
Object-n
data-2
+
functions
data-3
+
functions
data-4
+
functions
data is open to all functions. 
Each data is hidden and associated with an object. 


## Page 11

![Page 11](1.cpp_part1_page_11.png)

Example: PO VS. OO
11
engine
tires
steering 
wheel
accelera
tor
brakes
accelerate
switch on the ignition
steer
brake
Car = a sequence of functions (procedures)
Car = interaction between components (objects)
Procedure-oriented View
of car operation
Object-oriented View
of car operation
CAR


## Page 12

![Page 12](1.cpp_part1_page_12.png)

Class and Object
•
Class  ( Type in C )
✓Defines the abstract characteristics of a thing (object)
attributes (data) + behaviors (operations = methods)
•
Object ( Variable in C )
✓A pattern (exemplar) of a class
•
Instance
✓The actual object created at runtime
✓State: the set of values of the attributes of a particular object
•
Methods
✓functions
12
Ferrari
Hyundai
Object
(Instance at runtime)
Car
Class
Attributes
: color, capacity, max. speed, …
Methods 
: accelerate, brake, steer left, 
steer right, …


## Page 13

![Page 13](1.cpp_part1_page_13.png)

C++ Classes
• Similar to structure in C
13
class class_name {
public:
    // member variables
   int a, b, c;
   …
   // member methods (functions)
   void print(void);
   …
} ;
Class in C++
struct tag_name {
    type1 member1;
    type2 member2;
    …
    typeN memberN;
} ;
Structure in C
a collection of  heterogeneous types
a collection of  types and
associated functions


## Page 14

![Page 14](1.cpp_part1_page_14.png)

Class Declaration
14
class_name  instance_name1, instance_name2;
C.f. struct tag_name struct_variable, … ;
instance_name1
instance_name2
class_name
instantiation
methods
variables
methods
variables
methods
variables


## Page 15

![Page 15](1.cpp_part1_page_15.png)

C Style Design (Procedural) (1/2)
15
Bank
withdrawal
deposit
Client
name
telephone no.
account no.
password
balance
…
data
operations
withdrawal
deposit
…
Client
name
telephone no.
account no.
password
balance
…
…
data
operations


## Page 16

![Page 16](1.cpp_part1_page_16.png)

C Style Design (Procedural) (2/2)
16
withdrawal
deposit
…
Client
name
telephone no.
account no.
password
balance
…
…
Bank
Structure
struct client {
  char name[MAX];
  char tel[MAX];
  char account[MAX];
  char password[MAX];
  int balance;
};
struct client clients[MAX_NO];
void withdrawal (client &cli, int money);
void deposit (client &cli, int money);
Array of structures
Functions
references


## Page 17

![Page 17](1.cpp_part1_page_17.png)

C++ Style Design (Object-Oriented) (1/2)
17
…
Client
name
telephone no.
account no.
password
balance
…
withdrawal
deposit
…
Bank
withdrawal
deposit
Client
name
telephone no.
account no.
password
balance
…
data
operations


## Page 18

![Page 18](1.cpp_part1_page_18.png)

C++ Style Design (Object-Oriented) (2/2)
18
…
Bank
Client
name
telephone no.
account no.
password
balance
…
withdrawal
deposit
…
class client {
  char name[MAX];
  char tel[MAX];
  char account[MAX];
  char password[MAX];
  int balance;
  void withdrawal (int money);
  void deposit (int money);
};
client clients[MAX_NO];
“struct” can be omitted in C++
Class
member variables
are not required
In C++, structure is a class with all members public.
     struct s {   ,  ,   , }   class s {public:  ,  ,   , }  


## Page 19

![Page 19](1.cpp_part1_page_19.png)

#include<iostream>
#define MAX 10
using namespace std;
class record{
public:
char name[MAX];
int course1, course2;
double avg;
void print(void) {
cout << name << endl;
cout << “course1 = ” << course1 
<< “, course2 = ” << course2 << endl;
cout << “avg = ” << avg << endl;
}
};
int main( ) {
    record myrecord;
    myrecord.name = “Taesik Gong”;
    myrecord.course1 = 100;
    myrecord.course2 = 90;
    int sum = myrecord.course1 + 
                  myrecord.course2;
    myrecord.avg = ((double) sum) / 2;
    myrecord.print( );
    return 0;
}
Example: Class
19
instantiation
referencing
public member 
variables
member function call
member variables
Access specifier
member function
result>
Taesik Gong
course1 = 100, course2 = 90
avg = 95


## Page 20

![Page 20](1.cpp_part1_page_20.png)

class record{
public:
    char name[MAX];
    int course1, course2;
    double avg;
    void print(void);
};
void record::print(void) {
    cout << name << endl;
    cout << “course1 = ” << course1 
        << “, course2 = ” << course2 << endl;
    cout << “avg = ” << avg << endl;
}
class record{
public:
char name[MAX];
int course1, course2;
double avg;
void print(void) {
cout << name << endl;
cout << “course1 = ” << course1 
<< “, course2 = ” << course2 << endl;
cout << “avg = ” << avg << endl;
}
};
Definition of Member Functions
20
declaration & definition
declaration
definition : 
always after declaration
whole code in same file 
ex) “record.cpp”
“record.h”
“record.cpp”
•  don’t miss #include  “record.h” in “record.cpp”
It’s a good habit to separate files for readability and management


## Page 21

![Page 21](1.cpp_part1_page_21.png)

int main( ) {
    record myrecord;
    myrecord.name = “Taesik Gong”;
    myrecord.course1 = 100;
    myrecord.course2 = 90;
    int sum = myrecord.course1 +       
                  myrecord.course2;
    myrecord.avg = ((double) sum) / 2;
    myrecord.print( );
    return 0;
}
Member Variables & Functions 
21
#include<iostream>
#define MAX 10
using namespace std;
class record{
public:
char name[MAX];
int course1, course2;
double avg;
void print(void) {
cout << name << endl;
cout << “course1 = ” << course1 
<< “, course2 = ” << course2 << endl;
cout << “avg = ” << avg << endl;
}
};
always must reference
member variables
with instance name
member function
can reference member variables 
without class name 
inside member functions


## Page 22

![Page 22](1.cpp_part1_page_22.png)

Encapsulation
• Encapsulation conceals the functional details defined 
in a class from external world (clients).  
✓Information hiding
By limiting access to member variables/functions from outside
✓Operation through interface
Allows access to member variables through interface
✓Separation of interface from implementation
Similar to Stack data type and implementation (Lecture 11)
22
clients (users) only 
know interface.
no necessity for 
knowing inside
encapsulation


## Page 23

![Page 23](1.cpp_part1_page_23.png)

Encapsulation in C++
23
class class_name {
public:
    int a, b, c;
   …
    void print(void);
   …
private:
   …
protected:
   …
} ;
Class in C++
Access specifier
Encapsulation: hide inside
Interfaces : open outside 


## Page 24

![Page 24](1.cpp_part1_page_24.png)

Basic Features of C++
(Mostly same as C)
24


## Page 25

![Page 25](1.cpp_part1_page_25.png)

C++ Data Types
25
C++ Data Type


## Page 26

![Page 26](1.cpp_part1_page_26.png)

Fundamental Types
•  Basic data types
✓bool 
Boolean value, either true or false
✓char 
Character
✓short 
Short integer
✓int 
Integer
✓long 
Long integer
✓float 
Single-precision floating-point number
✓double Double-precision floating-point number 
✓enum 
User-defined type, a set of discrete values
✓void 
The absence of any type information
26


## Page 27

![Page 27](1.cpp_part1_page_27.png)

Declaration of a Variable
•  We can provide a definition, or initial value
•  Without definition, initial value is zero
•  Variable names may consist of any combination of 
letters, digits, or the underscore (_) character, but the 
first character cannot be digit
•  ex)
27
short  n;
int      octalNumber = 0400;
char   newline_character = ‘＼n’;
long   BIGnumber = 314159265L;
short  _aSTRANGE__1234_variABlE_NaMe;


## Page 28

![Page 28](1.cpp_part1_page_28.png)

Characters: char
•  Typically 8-bit
•  Literal
✓A constant value appearing in a program
✓Enclosed in single quotes
✓A backslash (＼) is used to specify a number of special 
character literals
28
‘＼n’ 
newline  
‘＼t’ 
tab
‘＼b’ 
backspace 
‘＼r’ 
return
‘＼0’ 
null 
 
‘＼’’ 
single quote
‘＼”’
double quote 
‘＼＼’ 
backslash


## Page 29

![Page 29](1.cpp_part1_page_29.png)

Integers: short, int, long
•  Short int, (plain) int, long int
•  Decimal numbers
✓ex) 0, 25, 98765, -3
•  Suffix “l” or “L” indicate a long integer
✓ex) 123456789L
•  Prefix “0” indicates octal constants
✓ex) 0400 (256)
•  Prefix “0x” indicates hexadecimal constants
✓ex) 0x1c (28)
29


## Page 30

![Page 30](1.cpp_part1_page_30.png)

Floating Point: float, double
•  Floating point literals
✓ex) 3.14159, -1234.567, 3.14E5, 1.28e-3
•  Default is double type
•  Suffix “f” or “F” indicate float
✓ex) 2.0f, 1.234e-3F
30


## Page 31

![Page 31](1.cpp_part1_page_31.png)

Enumerations: enum
•  A user-defined type that can hold any of a set of 
discrete values
•  Once defined, enumerations behave much like an 
integer type
•  Each element of an enumeration is associated with an 
integer value
•  ex)
31
enum Color {RED, GREEN, BLUE};   //RED=0, GREEN=1, BLUE=2
enum Mood {HAPPY=3, SAD=1, ANXIOUS=4, SLEEPY=2};
Color skycolor = BLUE;
Mood myMood = SLEEPY;


## Page 32

![Page 32](1.cpp_part1_page_32.png)

Pointers
•  Pointer holds the value of a memory address
•  The type T* denotes a pointer to a variable of type T
✓ex) int*, char*
•  The ‘address-of’ operator, ‘&’, returns the address of a 
variable
•  Dereferencing
✓ Accessing the object addressed by a pointer
✓ Done by * operator
32


## Page 33

![Page 33](1.cpp_part1_page_33.png)

Pointers
•  ex)
• Null pointer points to nothing
•  Void type pointer can point to a variable of any type
•  Cannot declare a void type variable
33
char ch = ‘Q’;
char* p = &ch; 
// p holds the address of ch
cout << *p; // outputs the character ‘Q’
ch = ‘Z’; 
 
// ch now holds ‘Z’
cout << *p; // outputs the character ‘Z’
‘Q’
#0x358299
Memory address
p =
ch =
Memory content
*
&


## Page 34

![Page 34](1.cpp_part1_page_34.png)

Arrays
•  A collection of elements of the same type
•  Index references an element of the array
•  Index is a number from 0 to N-1
•  ex)
34
double  f[3]; // array of 3 doubles: f[0], f[1], f[2]
double* p[10]; 
// array of 10 double pointers: p[0], ... , p[9]
f[2] = 25.3;
p[4] = &f[2]; // p[4] points to f[2]
cout << *p[4]; 
// outputs “25.3”


## Page 35

![Page 35](1.cpp_part1_page_35.png)

Arrays
•  Two-dimensional array
✓An “array of arrays”
✓ex) int A[15][30]
•  Initializing
✓ex)
35
int   a[4] = {10, 11, 12, 13}; // declares and initializes a[4]
bool b[2] = {false, true}; // declares and initialize b[2]
char c[] = {‘c’, ‘a’, ‘t’}; 
 
// declares and initialize c[3]
 
 
 
// compiler figures the size of c[]


## Page 36

![Page 36](1.cpp_part1_page_36.png)

Pointers and Arrays
• The name of an array can be used as a pointer to the 
array’s initial element and vice versa
•  ex)
36
char c[] = {‘c’, ‘a’, ‘t’}; 
char *p = c;  
// p point to c[0]
char *q = &c[0]; 
 
// q also points to c[0]
cout << c[2] << p[2] << q[2] 
// outputs “ttt”


## Page 37

![Page 37](1.cpp_part1_page_37.png)

References (“&”)
•  An alternative name for an object (i.e., alias)
•  The type T& denotes a reference to an object of type T
•  Cannot be NULL
•  ex)
37
string author = “Samuel Clemens”;
string &penName = author; 
// penName is an alias for author
penName = “Mark Twain”; 
// now author = “Mark Twain”
cout << author; 
 
// outputs “Mark Twain”
‘Samuel..’
author =
Memory content
penName =


## Page 38

![Page 38](1.cpp_part1_page_38.png)

Constants
•  Adding the keyword const to a declaration
•  The value of the associated object cannot be changed
•  ex)
• Replace “#define” in C for the definition of constants
38
const double PI = 3.14159265;
const int CUT_OFF[] = {90, 80, 70, 60};
const int N_DAYS = 7;
const int N_HOURS = 24*N_DAYS; 
// using a constant expression
int counter[N_HOURS];  
// constant used for array size


## Page 39

![Page 39](1.cpp_part1_page_39.png)

Typedef
•  Define a new type name with keyword typedef
•  ex)
39
typedef char* BufferPtr; 
// type BufferPtr is a pointer to char
typedef double Coordinate; 
// type Coordinate is a double
BufferPtr p;  
 
// p is a pointer to char
Coordinate x, y; 
 
// x and y are of type double


## Page 40

![Page 40](1.cpp_part1_page_40.png)

Dynamic Memory Allocation
40


## Page 41

![Page 41](1.cpp_part1_page_41.png)

Dynamic Memory and ‘new’ Operator
• Create objects dynamically in the ‘free store’
• The operator ‘new’ dynamically allocates the memory 
from the free store and returns a pointer to this object
• The operator ‘delete’ destroys the object and returns 
its space to the free store
• Accessing members
✓pointer_name->member (more preferred)
✓(*pointer_name).member
41


## Page 42

![Page 42](1.cpp_part1_page_42.png)

Dynamic Memory and ‘new’ Operator
•  ex)
42
Passenger *p;
//...
p = new Passenger; 
 
// p points to the new Passenger
p->name = “Pocahontas”; 
// set the structure members
p->mealPref = REGULAR;
p->isFreqFlyer = false;
p->freqFlyerNo = “NONE”;
//...
delete p; 
 
 
// destroy the object p points to


## Page 43

![Page 43](1.cpp_part1_page_43.png)

Example: Operators for Dynamic Allocation
43
C 
C++
Functions
Operators
void * malloc ( size_t size )
void * calloc (size_t nmemb, size_t size )
new data_type
new data_type[size]
void free(void *ptr);
delete scalar_variable;
delete [] array_variable;
Ex) To allocate an integer array of 100 elements
C 
C++
int *iptr;
iptr = (int *) calloc(100, sizeof(int)); 
…
free(iptr);
int *iptr = new int[100];
…
delete [] iptr;
Ex) To allocate a char
C 
C++
char *cptr;
cptr = (char *) malloc(sizeof(char)); 
…
free(cptr);
char *cptr = new char;
…
delete cptr;
returns a pointer 
addressing the 1st 
element of the array


## Page 44

![Page 44](1.cpp_part1_page_44.png)

Memory Leaks
• C++ does not provide automatic garbage collection
• If an object is allocated with new, it should eventually 
be deallocated with delete
• Deallocation failure can cause inaccessible objects in 
dynamic memory, memory leak
44


## Page 45

![Page 45](1.cpp_part1_page_45.png)

Strings in C++
45


## Page 46

![Page 46](1.cpp_part1_page_46.png)

Strings
•  C-style strings
✓A fixed-length array of characters that ends with the null 
character
✓This representation alone does not provide many string 
operations (concatenation, comparison,...)
•  STL strings
✓C++ provides a string type as part of its “Standard Template 
Library” (STL)
✓Should include the header file “<string>”
• STL: Standard Template Library
✓Collection of useful, standard classes and libraries in C++
46


## Page 47

![Page 47](1.cpp_part1_page_47.png)

STL Strings
•  Full name of string type is “std::string”
✓We can omit the “std::” prefix by using the statement “using std::string” 
(see “namespaces” later)
• Features
✓Concatenated using + operator
✓Compared using dictionary order
✓Input using >> operator
✓Output using << operator
47
C
C++
array of char types
string class
library functions
member functions of string class
relatively difficult, but many sources 
easy


## Page 48

![Page 48](1.cpp_part1_page_48.png)

STL Strings
•  ex)
48
#include <string>
using std::string;
//...
string s = “to be”;
string t = “not ” + s; 
 
// t = “not to be”
string u = s + “ or ” + t; 
// u = “to be or not to be”
if (s > t) 
 
 
// true: “to be” > “not to be”
     cout << u;  
// outputs “to be or not to be”


## Page 49

![Page 49](1.cpp_part1_page_49.png)

STL Strings
•  Appending one string to another using += operator
•  Indexed like arrays
•  The number of characters in a string s is given by 
s.size()
•  Conversed to C-style string by s.c_str() which returns a 
pointer to a C-style string
49


## Page 50

![Page 50](1.cpp_part1_page_50.png)

STL Strings
•  ex)
• Other C++ STL operations are providing
✓ex) extracting, searching, replacing,...
50
s = “John”;  
// s = “John”
int    i = s.size(); 
// i = 4
char c = s[3]; 
// c = ‘n’
s += “ Smith”; 
// s = “John Smith”
char *p = s.c_str(); 
// p is a C-style string


## Page 51

![Page 51](1.cpp_part1_page_51.png)

C Style String to C++
51
#include<iostream>
#include<string>
using namespace std;
main() {
  char cstyle[] = “UUIST";
  string cppstyle;
  cppstyle = cstyle;
  cppstyle[1] = ‘N';
  cout << "cstyle = " << cstyle << endl;
  cout << "cppstyle = " << cppstyle << endl;
}
Result>
cstyle = UUIST
cppstyle = UNIST


## Page 52

![Page 52](1.cpp_part1_page_52.png)

C++ Style String to C (1/2)
52
#include<iostream>
#include<string>
using namespace std;
main() {
  string cppstyle = “UNIST";
  const char *cstyle;
  cstyle = cppstyle.c_str();
  cout << "cstyle = " << cstyle << "\n";
  cout << "cppstyle = " << cppstyle << "\n";
}
return value : const char *
∴cannot modify a string
Result>
cstyle = UNIST
cppstyle = UNIST


## Page 53

![Page 53](1.cpp_part1_page_53.png)

C++ Style String to C (2/2)
53
#include<iostream>
#include<string>
using namespace std;
main() {
  string cppstyle = “UUIST";
  char* cstyle = new char [ cppstyle.size() + 1];
  strcpy( cstyle, cppstyle.c_str() );
  cstyle[1] = ‘N';
  cout << "cppstyle = " << cppstyle << "\n";
  cout << "cstyle = " << cstyle << "\n";
  delete[] cstyle;
}
can modify a string
Result>
cppstyle = UUIST
cstyle = UNIST


## Page 54

![Page 54](1.cpp_part1_page_54.png)

Scope, Namespace, 
Casting, Control Flow
54


## Page 55

![Page 55](1.cpp_part1_page_55.png)

Local and Global Variables
•  Block
✓Enclosed statements in {...} define a block
✓Can be nested within other block
•  Local variables are declared within a block and are 
only accessible from within the block
•  Global variables are declared outside of any block and 
are accessible from everywhere
•  Local variable hides any global variables of the same 
name
55


## Page 56

![Page 56](1.cpp_part1_page_56.png)

Local and Global Variables
•  ex)
56
const int cat = 1; 
 
// global cat
int main () {
     const int cat = 2; 
 
// this cat is local to main
     cout << cat; 
 
// outputs 2 (local cat)
     return EXIT_SUCCESS;
}
int dog = cat; 
 
// dog = 1 (from the global cat)


## Page 57

![Page 57](1.cpp_part1_page_57.png)

Scope Resolution Operator (::)
57
#include <iostream>
using  namespace std;
int  x;
int main()
{
       int  x;
       x = 1;
       ::x = 2;
       cout << "local x = " << x << endl;
       cout << "global x = " << ::x << endl;
       return 0;
}
local x hides global x
assign to global x
result>
local x = 1
global x = 2


## Page 58

![Page 58](1.cpp_part1_page_58.png)

Namespaces: Motivation
•
 Two companies A and B are working together to build a game software 
“CatParty”
•
A uses a global variable
✓struct Tree {};
•
B uses a global variable
✓int Tree;
•
Compile? Failure
•
An alternative solution
✓A: struct Atree {}; 
B: int BTree; 
→ dirty, time consuming, inconvenient
•
Let’s define some “name space”
•
Very convenient in making “large” software
58


## Page 59

![Page 59](1.cpp_part1_page_59.png)

Namespaces
•  A mechanism that allows a group of related names to 
be defined in one place
•  Access an object x in namespace group using the 
notation group::x, which is called its fully qualified 
name
•  ex)
59
namespace myglobals {
     int cat;
     string dog = “bow wow”;
}
myglobals::cat = 1;


## Page 60

![Page 60](1.cpp_part1_page_60.png)

The Using Statement
• “using” statement makes some or all of the names 
from the namespace accessible, without explicitly 
providing the specifier
•  ex)
60
using std::string; 
 
// makes just std::string accessible
using std::cout; 
 
// makes just std::cout accessible
using namespace myglobals; 
 // makes all of myglobals accessible


## Page 61

![Page 61](1.cpp_part1_page_61.png)

Example : Namespace
61
#include <iostream>
namespace IntSpace{
      int data;
      void add(int n){ data += n; }
      void print(){ std::cout << data << std::endl; }
}
namespace DoubleSpace{
      double data;
      void add(double n){ data += n; }
      void print(){ std::cout << data << std::endl; }
}
int main()
{
      IntSpace::data = 3;
      DoubleSpace::data = 2.5;
      IntSpace::add(2);
      DoubleSpace::add(3.2);
      IntSpace::print();
      DoubleSpace::print();
      return 0;
}
same variable name is allowed in 
different namespaces
result>
5
5.7


## Page 62

![Page 62](1.cpp_part1_page_62.png)

Casting
• Casting refers to converting a variable from one data type to 
another
• This can be necessary when you want to change how a value is 
interpreted by the compiler
✓E.g., arithmetic operations between different numeric types
62


## Page 63

![Page 63](1.cpp_part1_page_63.png)

Traditional C-Style Casting
int 
cat = 14;
double dog = (double) cat; 
// traditional C-style cast
double pig = double(cat); 
// C++ functional cast
int 
i1 = 18;
int 
i2 = 16;
double dv1 = i1 / i2; 
 
 
// dv1 = 1.0
double dv2 = double(i1) / double(i2); 
// dv2 = 1.125
double dv3 = double( i1 / i2); 
 
// dv3 = 1.0
63


## Page 64

![Page 64](1.cpp_part1_page_64.png)

Implicit Casting
int 
i = 3;
double d = 4.8;
double d3 = i / d; 
// d3 = 0.625 = double(i) / d
int 
i3 = d3;  
// i3 = 0 = int(d3)
 
 
// Warning! Assignment may lose information
64


## Page 65

![Page 65](1.cpp_part1_page_65.png)

Control Flow: If Statement
if (<boolean_exp>)
 
<true_statement>
[else if (<boolean_exp>)
 
<else_if_statement>]
[else
 
<else_statement>]
65


## Page 66

![Page 66](1.cpp_part1_page_66.png)

Control Flow: Switch Statement
char 
command;
cin >> command;
switch (command) {
     case ‘I’ :
          editInsert();
          break;
     case ‘D’ :
          editDelete();
          break;
     case ‘R’ :
          editReplace();
          break;
     default :
          cout << “Error\n”;
          break;
}
66


## Page 67

![Page 67](1.cpp_part1_page_67.png)

Control Flow: While & DO-While
while (<boolean_exp>)
 
<loop_body_statement>
do
 
<loop_body_statement>
while (<boolean_exp>)
67


## Page 68

![Page 68](1.cpp_part1_page_68.png)

Control Flow: For Loop
for ([<initialization>];[<condition>];[<increment>])
 
<body_statement>
68


## Page 69

![Page 69](1.cpp_part1_page_69.png)

Functions and Overloading
69


## Page 70

![Page 70](1.cpp_part1_page_70.png)

Functions
bool evenSum (int a[], int n); 
// function declaration
int main() {
 
const int listLength = 6;
 
int list[listLength] = {4, 2, 7, 8, 5, 6};
 
bool result = evenSum(list, listLength); // call the function
 
if (result) cout << “even sum.\n”;
 
else 
   cout << “odd sum.\n”;
 
return EXIT_SUCCESS;
}
bool evenSum (int a[], int n){ 
//function definition
 
int sum = 0;
 
for (int i = 0; i < n; i++) sum += a[i];
 
return (sum %2) == 0;
}
70


## Page 71

![Page 71](1.cpp_part1_page_71.png)

Function Overloading
71
•#include<iostream>
•using namespace std;
•int abs(int n) {
•
return n >= 0 ? n : -n; 
•}
•double abs(double n) {
•
return (n >= 0 ? n : -n);
•}
•int main( ) {
•
cout << “absolute value of ” << -123;
•    cout << “ = ” << abs(-123) << endl;
•
cout << “absolute value of ” << -1.23;
•    cout << “ = ” << abs(-1.23) << endl;
•}
In C, you can’t
use the same name for
multiple function definitions
C++ allows multiple 
functions with the 
same name as long as 
argument types are 
different: the right 
function is determined at 
runtime based on 
argument types
Type matching
Type matching


## Page 72

![Page 72](1.cpp_part1_page_72.png)

Polymorphism
• Allow values of different data types to be handled using 
a uniform interface.  
• One function name, various data types
✓Function overloading is a type of polymorphism
• Merit
✓improve code readability 
• Ex.
72
C
abs ( )
labs ( )
fabs ( )
int
long int
floating point
C++
abs ( )
int
long int
floating point


## Page 73

![Page 73](1.cpp_part1_page_73.png)

Default Arguments (1/2)
73
#include<iostream>
using namespace std;
int calcCubeVolume(int width = 1, int height = 1, int depth = 1);
int main ( ) {
cout << “[def, def, def] ” << calcCubeVolume( ) << endl;
cout << “[2, def, def] ” << calcCubeVolume(2) << endl;
cout << “[2, 2, def] ” << calcCubeVolume(2, 2) << endl;
cout << “[2, 2, 2] ” << calcCubeVolume(2, 2, 2) << endl;
  return 0;
}
int calcCubeVolume(int width, int height, int depth) {
return (width * height * depth);
}
result>
[def, def, def] 1
[2, def, def] 2
[2, 2, def] 4
[2, 2, 2] 8
default values
First arg. overrides the default value.
All default values are used.
First two args. overrides the default values.
All args. overrides the default values.


## Page 74

![Page 74](1.cpp_part1_page_74.png)

int calcCubeVolume(int width = 1, int height = 1, int depth = 1);
int calcCubeVolume(int width, int height = 1, int depth = 1);
int calcCubeVolume(int width, int height, int depth = 1);
int calcCubeVolume(int width = 1, int height = 1, int depth);
int calcCubeVolume(int width = 1, int height, int depth = 1);
Default Arguments (2/2)
74
Argument names can be omitted 
in prototype.
Default arguments may be provided for trailing arguments only.
int calcCubeVolume(int = 1, int = 1, int = 1);
( O )
( O )
( O )
( X )
( X )


## Page 75

![Page 75](1.cpp_part1_page_75.png)

C++ Operator overloading
• User can overload operators for a user-defined class or types
– Example) String s1(“gong”); String s2(“taesik”); String s = s1+s2;
– How? 
– define an operator as a function to overload an existing one
– operator followed by an operator symbol to be defined.
•
define an operator + → operator+
•
define an operator ++ → operator++
•
define an operator << → operator << 
– To avoid confusion with built-in definition of overload operators, all 
operands in the basic types (int, long, float) are not allowed 
75


## Page 76

![Page 76](1.cpp_part1_page_76.png)

Example : Operator Overloading
76
int main()
{
  Day d = tue;
  cout << "current : ";
  print(d);
  for(int i = 0; i < 6; i++){
      ++d;
  }
  cout << "after 6 days : ";
  print(d); 
  return 0;
}
use of overloaded operator
#include <iostream>
using namespace std;
enum Day { sun, mon, tue, wed, thu, fri,sat };
Day& operator++(Day& d)
{
  return d = (sat == d) ? sun : Day(d+1);
}
void print(Day d){
  switch(d){
   case sun : cout << "sun\n"; break;
   case mon : cout << "mon\n"; break;
   case tue : cout << "tue\n"; break;
   case wed : cout << "wed\n"; break;
   case thu : cout << "thu\n"; break;
   case fri : cout << "fri\n"; break;
   case sat : cout << "sat\n"; break;
  }
}
Operator overloading
result>
current : tue
after 6 days : mon


## Page 77

![Page 77](1.cpp_part1_page_77.png)

Operator Overloading (==)
bool operator == (const Passenger &x, const Passenger &y) {
 
return  
x.name  
== y.name
 
 
&& 
x.mealPref 
== y.mealPref
 
 
&& 
x.isFreqFlyer 
== y.isFreqFlyer
 
 
&& 
x.FreqFlyerNo 
== y.FreqFlyerNo;
}
77
Passenger taesik, iu;
…
…
if (taesik == iu)
{
…
}
enum MealType { NO_PREF, 
REGULAR, LOW_FAT, VEGETARIAN };
class Passenger{
public:
string name;
MealType mealPref
bool isFreqFlyer;
string freqFlyerNo;
};


## Page 78

![Page 78](1.cpp_part1_page_78.png)

Operator Overloading (<<)
ostream& operator << (ostream &out, const Passenger &pass) {
 
out << pass.name << “ ” << pass.mealPref;
 
if (pass.isFreqFlyer) {
 
 
out << “ ” << pass.freqFlyerNo;
 
}
 
return out;
}
78
Passenger taesik, iu;
cout << taesik;
cout << iu;


