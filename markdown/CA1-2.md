# Transcription of CA1-2.m4a

| Time | Content |
|------|--------|
| 0:00:00 | So in this context, the most important thing is the abstraction.  So we need to abstract the context system so that we can easily understand the context or architecture in this.  So, you can see that there are two modes of the computation.  And from this 2013, the smartphone was the most important and widely used in our company.  So, I'm actually enjoying to my university at this point, 2013.  So before joining to the university, I mean when I was a high school student, the smartphone was a slightly unique and smart point instead of the unique feelings. |
| 0:01:00 | So, only used to have smart paintings.  After the 2010, when I joined the university, I arranged to learn the quantities of the smartphone.  So, instead of a small computer, even gaming content, it's from now on.  It's a smart phone and a tablet device.  So now, we can categorize the computer with the big kinds of things.  So, we're sort of a first-star of the one that we want to keep.  So, you know, a smartphone or a tablet or a smartphone can be categorized with this tablet.  So, you just apply it to the battery and you just apply it to the internet. |
| 0:02:00 | And nowadays, it's getting some of the incentive computer is getting incentive.  So, it's a small size of the computer.  It's embedded in the card, like the tablet or the smart installation, smart TV or the smartphone speaker.  So, this is the kind of computer, it's known as the IT, it has things, and Edge devices.  So, these devices, the computer, the chip is embedded in the devices.  So, just hit it, hit it as a computer or some systems. |
| 0:03:00 | And you know, some needs something like a concentrated power and concentrated power, because you have a concentrated environment.  So, this is a question, but it is important to have more power, but as we need to have that no problem.  And the third thing is cloud computing.  So, now, a computer is not existing in our smartphone, as it is existing in our multi-stime.  And we can connect to the computer so that we can save some data for the language.  And of course, we can compute some things by using the computer.  Or as nowadays, we can treat the model by using the cloud computing. |
| 0:04:00 | So, Amazon, Microsoft and Google, why do you choose this kind of computer?  And the portal of software, like a PMP or a computer and a virtual computer, is the cloud.  So, this is the important stuff you are using the HTTPT that belongs to the websites that have an interface of the HTTPT from the browser.  So, the portal of the software and it is a PMP.  And the very good answer is used by a multiple, so it is a portal of cloud and a cloud.  So, this is the computer.  And we can see the trend over the technology. |
| 0:05:00 | So, you can see that in one sheet, the capacity, the local capacity is increased by by providing new kinds of cheap, touch-on-wise,  so you can research and invest in it.  So, it is increasing capacity and the model technology, so it increases the performance and it uses the cost.  So, you can see that by first the computer, the actual cloud, is used in 1913-21.  So, this computer of the company is utilised by leverage back to 2, which is only as a G1.  But it is the very big size, so the cost is high, the cost is high, but the cost is not good. |
| 0:06:00 | So, all these performance is getting better and the cost is reduced by utilising this kind of a year design.  This is like the distributed chip, the distributed chip.  There are lots of the trend disturb, so that we can have, or kinds of the resource, or the export of data or the cost of data.  So, these are the trends of the technology, so actually it is a positive thing.  Now, this is important to have artificial.  So, I mentioned these kinds of the signals, so you will learn from the present principles, |
| 0:07:00 | using the modern computer architectures to improve the performance of the features.  So, I mentioned about the principles using modern computer architectures, so we are just able to know what is the structure of the computer.  So, to understand the structure of the computers, you need to restrict the computer architecture.  So, let's forget the details here.  So, you mentioned about the rest of the computers, like desktop and software,  not computer, smartphone, or embedded computer such as TV or smartphone speaker.  Well, there are common things, they are all of the computers, so we can now define what is the computer. |
| 0:08:00 | So, this is really, you can think that the computer really does that when you see it, it uses problem and it uses the internet.  And, my computer will compute the computer, the things that I see in the comment, and we will be the computer of the job.  So, computing is for the function of the computer.  So, now we can actually move kinds of the computer with the three kinds of radios.  We actually get the computer with the three kinds of radios.  So, first thing is the educational software, and second thing is the systems of DUR and third thing is the hardware. |
| 0:09:00 | So, we just actually get the computer with the three kinds of radios.  So, then why do we actually get those kinds of things?  Why actually get that?  So, we can think that, you know, so we buy actually something, so we can kind of detail things and we can make the easier to understand.  So, by actually doing the content, we can understand each other, understand the customer, and we can understand the components.  And, you know, external roles, each developer, to focus on their part.  So, I mentioned that the concept of the software and hardware. |
| 0:10:00 | So, you know, maybe there is something like a developer that is working on hardware, only working on hardware.  And, some developer is the higher management developer, such as VEG, or the hardware developer.  In the case of the developer, only one of the developers can focus on the hardware.  And, hardware developer only can focus on his own job, or developing a hardware.  So, this is going to come to an abstract computer, so that the developer can focus on their parts.  And, external roles, to build a components system.  So, you know, we make the easier, we make things easier.  And, each developer can focus on their parts.  So, we can now combine those kinds of things, so that can build a more complex system. |
| 0:11:00 | So, by hamstring with something, by how to use something, we can combine those kinds of things,  and make more complex systems such as a computer.  So, it is important to have such something.  So, actually, this is not only focused on the computer architecture, so, in your life or in your research,  you just important to abstract the software.  So, abstract the program and you know, you can get the solution by abstracting some kinds of components.  So, we actually can come to terms with things, the software, the software, and the hardware.  So, now, let's talk about details about the computer below.  To program, to get from your program to get the computation results. |
| 0:12:00 | So, first of all, your bugs can be made, you can develop the program by using the hardware languages such as C or D principles, Java, or Python.  So, here's the application software.  So, by looking at something like the program, by looking at the languages specification,  C is set up, you can make your own program like this.  And now, this program, this higher program, will be compiled in the compiler,  so that you can get a separate language, which is familiar with the hardware.  So, both is real-time, but it is familiar with the hardware. |
| 0:13:00 | And finally, a separate word, we are from a separate language to machine language, which is called a bit binary, but a single word.  So, there is the concept of compilation, and with those kinds of generating the binary code,  the operating system can, you know, connect with the hardware, so that the hardware can execute those kinds of the,  can be loaded, and the code can be the most concept of the binary code, and we're asking it.  The programs, so they can, you can get the computation results, so that the end user can get computation results.  That's the detail, the flow of the execution of the program. |
| 0:14:00 | So, one is ready.  One June, one June, one June, okay, so that's the equation.  So, I'm trying to, you know, she's questioning that, you know, in the EU world, see the consequences,  there is something like the compiling of the process, but you know, in the Java world, you know, in the Java world, there is something like the interpray term.  And so, there is a good pressure and, you know, the pre-term is the different concept of the compiler.  So, they have different architecture of the system, so it is something like a virtual environment.  So, if they hold the virtual environment, they talk with the program, so it is different concept, but you know, so we can consider it as the compiling reason, |
| 0:15:00 | because, you know, bytecodes can be represented with the, you know, you should show it.  In terms of the computation, it can be the common one, so we can consider it with the, actually in the details of the product,  but we can think it as the common thing with this kind of concept, okay.  And we have an other question, okay, so now, as I mentioned about the process of the compiler,  and you know, the execution from the compiler.  So, I mentioned that this kind of the process, from the compiler language to machine language,  to convert it to the compiler language to machine language is known as the compiler language.  So, I spoke about the compiler language in detail, so we will convert the compiler language to the version of the compiler language, |
| 0:16:00 | that compilter can understand, you know, this kind of the, what should, why I'm calling, can be interpreted from the compilter.  So, the compilter cannot be interpreted by the kind of language.  So, we need to convert the language to a simple language.  So, in the high number of languages, you should be just, you know, it is a human-level, it is a consistent with the human-level code.  So, it is closer to the problem domain, so if you have something like the problem in your domain,  then, you know, you should make tools, tools for the sweet-cover language.  And, we promise, or, product, to be added, product, to be added.  So, let me ask that, no.  So, if you, you know, develop those kinds of programs with the C, C language, then this code can be executed in the window in your predecessor, |
| 0:17:00 | but it can be executed in the, you know, in the fields, environments, you know, in the main body, but it can cause, you know, the, you just have higher learning things.  So, we just, in this, in this, in this, I mean, this, I think, it's such a barrier.  So, you know, we do not need to understand anything, and to consider what lower learning things such as systems are so very hard to learn.  So, it is, like, for October, so, it is like, for October, and for October, in this vein, these two languages.  And, by, you know, passing the compiler, you can get the custom language.  You can eat this last, fun, re-double, format. |
| 0:18:00 | So, that is the language. You can't, you can't interpret those kinds of things. You can want to predictation and add those kinds of two values or something.  So, you just, if you want to read over things, or know, you just, not, let's read over that, the height of a language.  So, it is a text journal, which is taken over the instruction.  So, I mentioned a lot of instruction in here. So, here, instruction is the command prep, and the hardware percent.  So, each kinds of the command, here, is the instruction in the second language.  And, by passing the assembler, here, finally, you can get the hardware representation, which is the binary one.  So, just concentrate the zero and four. And, you want to think, is that you call the instructions and data.  So, that means that, you know, we, uh, wrote about the instruction in here. |
| 0:19:00 | And, these kinds of instructions can be meant to the group of bits of the, uh, hardware representation, here, so binary one.  So, you just want to talk about it, so that you can, uh, by the input of the instructions, maybe the machine can, you know,  the, the, the, the, the separate, or can, you know, uh, translate to choose the binary command in here.  Okay, then it's the details of the library, so, the command, or the command.  Do you have any questions on the, one, two?  Handsome? Okay, handsome.  Okay, so, we need to get that, okay. |
| 0:20:00 | So, I'm just focusing on the instruction.  So, I'm just focusing on the instruction. So, he asked that, um, you know, the, what's the number of it?  It has the same format, but, you know, I, uh, maybe the, the machine, maybe she can have the different kinds of the, uh, binary, because, you know, the, the hardware is different.  So, in the case, you know, the CPU, uh, be, so I'm in general of the instruction, later in here.  So, in the case, uh, you know, the, uh, the kinds of the case, uh, maybe awkwardly cause there are, how do you achieve this different, uh, each other?  You know, if they are the different family, then maybe you have the different kinds of the machine, right?  So, in the case, you know, the systems of the world, uh, systems of the world, they're, uh, achieved very well. |
| 0:21:00 | So, um, in, in, in one sheet, uh, they are, uh, central, and in the other parts of the sheet, they are, uh, different kinds of the same roles, then you can interpret with different kinds of the machine.  Okay?  Okay, thank you. So, I'm going to get the question.  Uh, okay, so, now, I just mentioned about the compilation process today.  So, now, let's look at the details of the, you know, the hardware. So, you know, we're not going to the problem.  So, by receiving the machine, by the model.  Um, so, the hardware of the components of the components, we can see the main three kinds of components too.  So, this is the process, to just, uh, a CPU, central processing, you need. |
| 0:22:00 | So, for instance, the entire, uh, single world, I think, like, um, um, um, chip world, because the main, M3, and wanted to, this is a process.  And now, we can see the main memory code, which is a source of the data.  And you can see the code, no matter, so this is a package.  So, um, in this package, we were, we were, we can't install a source of data.  So, um, and, you know, you can see that I will divide neutral, and divide such as, more than 1 miles and 1,000, you know, as a mouse.  Um, we can, I'm not, uh, give you the input, and, you know, what we, uh, get, how do you build, um, of the, this course, the R, and everything.  So, it is the final thing, so, here is, uh, let's focus on this kind of the three kinds of the main components. |
| 0:23:00 | So, as I mentioned before, the main memory, and how it is, we're, no, store, we see the data.  We have the, uh, this kind of, uh, operation.  So, there are, uh, each curve, uh, you have to lie between the main memory and the hard disk, which is not in the box.  And these balls are very, um, you know, uh, moved the data from here to here, or from here to here.  So basically, we're saying, you restore the data.  And, uh, the process of the, is the input, or operation.  So, especially in those, uh, to perform the operation, they need something like a data.  So, uh, this is the process of, you fetch the data from the main memory.  There's, uh, the data is code in the main memory, so, it will fetch the code that, or you will, um, you know, give more, or store the data. |
| 0:24:00 | So, uh, there is the interaction between the, uh, process, the memory, and the hard disk.  So, uh, let's focus on this, this two things, the memory and the hard disk, which is, uh, which will exceed the data here.  So, it's the case for data here.  So, uh, so you can say, main memory is the, uh, router, uh, border-tatter, uh, main memory.  So, here, what it means, uh, the key parts of the, uh, the query, so it's a temporary.  So, if you, uh, power of your computer, then, before the, uh, data, then, then, then, then, then, then, then, then, memorize the memory, maybe, uh, maybe, flush.  So, uh, it is nothing, it's true.  So, in the main memory, um, you know, data, and, uh, like, the, the data, but, uh, if you, uh, tell, uh, your, tell, uh, your computer, then, on the memory, you will use it. |
| 0:25:00 | And, you just, uh, the, long-term memory here, it's a second memory, uh, just like, uh, uh, HDD, HDD, and SSD.  And, you know, we're, um, you know, present with the mind, because, in case of HD, you know, SSD, uh, is working with, uh, electronic, uh, electronic things, and with, uh, uh, uh, uh, so it is data.  And, you know, so, uh, we're so fresh now, you know, uh, as I said, I'm going to discuss this in parallel and so, and, uh, of parallel use, is, uh, the second memory.  And, actually, it is the safe place for data, you know, so you can, uh, so you can, you know, consistently save the data, uh, by saving data to those kinds of hardware.  So, as I mentioned, it was this kinds of memory is, uh, temporary thing, and heartiness is, uh, uh, safe place for data. |
| 0:26:00 | So, now, um, so, uh, so if you compile your program from your computer, then, um, you know, the compile user is, uh, by the code here.  So, all of the, um, compile data, uh, to maybe store the, uh, heartiness.  So, if you, uh, compile your data, then, um, you can compile your, um, your social data, the generated binary is told in the heartiness, or your SSD.  And, in this queue, in the processor, there are two kinds of main components, so, control, to the plane, and data path. |
| 0:27:00 | To this.  Control, uh, it's just a conductor of the computer, so we, uh, make some, we leave some comments to the data path, the neural course, the memory and heartiness.  And, so, it is just, uh, mainly, you know, components, and make content of the, uh, the computer.  And, uh, in the, uh, data path, data path, maybe perform, or create some more, uh, the receiver, so by, uh, by receiving the comments from the, uh, control, by receiving the data from the memory, to be, uh, performed, the competition.  So, now, let's ask the crystal program, this program A, here.  So, uh, let's also, uh, make your own machine, or your machine, so you can ask the program in those kinds of the program A. |
| 0:28:00 | So, uh, already, there are, uh, there is, uh, compile program, binary, here, the hundredth is correct, here.  So, for some, uh, uh, country community, to be, load the program from the hundredth is, to the main memory.  So, every loaded to the main memory, so some set of the memory will contain with the program.  So, actually, this is not a code section in the memory, there are some sections in the memory, and here, this kind of the, such a code will be stored in the code section.  And, now, um, it will fetch the instruction of my own, so I'm, here, one by one.  So, for some, I'll be, uh, fetching these kinds of, first, instruction to here. |
| 0:29:00 | So, processor, now, now processor, we see, uh, is received, the binary, here, instruction, one instruction.  So, now, what do we need, uh, we're, you know, collected to, uh, data path, so that we can ask into the instruction.  And, what these kinds of the computation, you know, so you can, uh, store the data in case, uh, so we have, uh, we need to store the, uh, the program, uh, something like, uh, the argument value over the data, that is what it's, so we're, uh, on load and store the data from the, uh, data.  So, uh, I mentioned about the, uh, CPU, so CPU, we have the data path and the data path, the operations of data, some of the comments, and, uh, how to really, uh, send the data path, and we, and I devices, um, to, uh, the, uh, data. |
| 0:30:00 | And, so I mentioned about the two main components in here, and there are other kinds of components, which is known as the registers, and cache, which, what's the, so I mean, so I mentioned that, you know, the processor, you, um, you know, focus on the computation, but, you know, there are, um, small, paste, two, you know, stored the data, which is known as the register, or cache.  So, I mentioned about, I mentioned about, you know, the details of what the register is, and that's the term.  Um, and, you know, the, although we have to make every interior, the proposal, the register, the interior is that, is very fast, to, um, you know, fast, fast to lower the data. |
| 0:31:00 | To, to store the data from the register, and get, get, uh, the data from the register, just like that. So, we, uh, in the processor, uh, before the register, cache.  So, what, this is, questions that, why does the developer, the developer?  question vale.  What does it mean?  Come on to the bottom. |
| 0:32:00 | So I turn it into the initial question.  So in case of the bottom,  so you know if you want to  give more of your core and  higher level, then the bottom is  the application of the two.  If you want to devolve the  instructions, then maybe  needs to be treated  with this type of training.  So is there any other question?  Okay, so it is,  so I turn it,  devolving self is not popular,  but it needs to, you know,  something like utilize a hardware to,  you know, maybe it's,  if I want to  utilize a breakpoint,  then you need to |
| 0:33:00 | interact with this kind of  security now,  and make a memory.  So in the case, you know,  your application is also  clear and it is to  interact with the  interact with this kind of  interaction.  So this is the example of  the possession  and current A  tracking.  So you can say the other  was, you know, this is the  interface for the main memory.  So you can be  connected with the main memory.  And you can see that  you have a course,  this is the main,  the real-world,  this is the people.  So it is the  process.  And it can see that  cache data or  serialings is the  register inside the  CPU.  And you know,  it's the process.  Also, I mean,  in the app,  it's the GPU. |
| 0:34:00 | So,  I mentioned the one that  abstractions have  still been the contents  of the CPU.  So this is the information  before you figure out the  application you're going to  do not need to help us  handle about the  suburb and  inclusion and the  hardware, the, you know,  structure of the  hardware.  So just, all you need to  do is to need the  document of the  C language,  or sometimes  a Java language,  so that you can  make your own  movement with the  higher language.  So this is the  main important  concept of the  abstractions.  So, you're  in this kinds of  interface.  C language specification  is the  abstracted thing of the  hardware and, you know,  operating system,  system hardware,  assistions of the  field. |
| 0:35:00 | So, you know, the  is concept definition  available to the  main center of the  system and the hardware.  So, but you guys are  not the  contest scientists.  So, I'm getting more  closer to the contest  scientists to you.  Need to talk a  little bit about the  lower level of things.  So you're in the  abstraction, and I'm  very high on the  lower level of  communication details,  so I'm providing  one of these.  So, right, what?  So, I mentioned that  this application  software, you know,  is possible with  repetition in thisse 처�ice.  It's possible with  the  hardware that we  can a  publisher, 3172  Integration  is a |
| 0:36:00 | architecture, the software or the mobile or system  or predecessor, or the computer or computer writer  can develop all the program.  So it is the software and the hardware interface.  So these kinds of program, what  those kinds of the compiler or predecessor  or systems of code do not need to know about the details  of the hardware.  So the technology of hardware is not necessary.  So in such a way, it's not easy.  So it is not an interface between hardware  and the rule of software.  So it is the hardware reflection.  So hardware reflection means that this kind of |
| 0:37:00 | frequency is the hardware reflection.  So hardware reflection is basically  the choose of the compiler or program.  So this kind of infrastructure set up  actually includes infrastructure set.  So I mentioned about the instruction.  So instruction set is the whole set of the instruction.  And there are a lot of times, many instructions  where the plan is built.  So we need to understand about the plan  and time if you want to develop your existing components  and compile your own.  When data files, integrals, or something,  or something, or something.  And the memory of this is always the right thing.  So I will call it the details of which  are in the next section.  So I just have to introduce about ISA,  initials of the architecture here.  So you can see that this kind of frequency |
| 0:38:00 | is very current.  So software is paying with the initials of the architecture.  But in the middle of the initials of the architecture,  the complex hardware just supports higher results.  So that's the concept of the initials of the architecture.  Now I'll book the text book.  The title, the subtitle is that hardware is to interface.  So now we can understand that the meaning of the subtitle  here.  So hardware and software increase, just IEC.  So this is the summary of this initial transatlantic  feature.  So I mentioned that this kind of the hardware  is to be able to have the lower-end results  of the layer to the transfer system  and a separate lower-end.  And the below of the instance is an architectural view. |
| 0:39:00 | It can see the process from memory  to the system, or data platform,  to the unit, or so.  And then more and more events you can see  at the circuit design and the fish curve design.  So in our lecture, we read a lot about the initials  of the architecture.  And there will be a level of the cluster  of the process of memory and the system.  And how the process is working on the data path  and the complex design.  So these are the scope for our dimension.  So in the comment or architectural view,  so we have seven-grade icons.  So I mentioned the one that has a source of appeal.  So the competitor can be asked to limit  the three kinds of components.  So it needs to be asked for a source.  So we just say, what about the idea  that the researchers put in the Compton |
| 0:40:00 | architecture?  And make the column case best.  And when we develop some components,  we can have a column concept pattern.  In this case, architecture level should make these kinds  of cookies best, so that the overall performance  can be controlled.  And there are parallelism between parallelism.  Institutions, so that the multiple kinds of the instructions  can be executed in similar manner.  You can also have parallelism between parallel processing  and pipeline.  So two is prediction is important.  Things are prediction is also great time.  We also have an idea in Compton architecture.  And higher, higher, healer or memories. |
| 0:41:00 | So I mentioned that some cell of the memory  such as how it is and the memory in length  and memory that existing as a C key.  So those kinds of the memories can  propose the higher key of the memory.  So you just need to look at the thing to improve the performance.  So just a little idea and dependability  is really anything that is addition of our test.  So actually, it is relating to the hardware.  So there are lots of different hardware  tools so that I can make the trustful environment  from the computing.  So here is our talk of the data that we see later. |
| 0:42:00 | The work is special.  So you can see the memory is just a little bit  just the shadow of what this means when I explain the concept.  So if someone asks some question about, hey,  so what kinds of things you learn from the Compton architecture,  that can answer with those kinds of things with the details.  And you may, so that's the set of things.  I guess a computer architecture.  OK, so now we have something.  So let's take a break for two minutes.  So if you have any question, then you can discuss  with your colleagues while you can call to the team. |
| 0:48:00 | So before the break time, so the copy  depends on the external computer.  So by actually the conferences, you can see,  you can simply find the understanding of the conferences  and the interaction environment.  So now it's focused on the performance experience.  So how we can create the conference?  The measure that the Compton architecture  is designed to improve performance of the competitions.  So then what is the main metrics, main criterion  for computing performance? |
| 0:49:00 | So let's assume that we consider the two kinds  of the airplane in general.  And four kinds of the airplane in general.  And with the two kinds of metrics, two kinds of the return.  So in terms of the passenger capacity,  suppose the airplane is good airplane.  But if you consider about the course is key,  it's third airplane is the better airplane.  So let me say that it depends on the metrics  and their environment and their performance.  So we talked about the computer. |
| 0:50:00 | So we consider the performance.  There are lots of metrics that interest the time  and the size of the switch, or the other kinds of the things.  So in our lectures, we can focus on the time.  So most important thing is the time.  So we wanted to finish our program on your time  by a hacking of the computer architecture.  So our main metric is the signal time, the processor.  The signal time.  And this kind of the signal time can be calculated  with the kinds of the tools.  So the instruction program, the instruction process,  instruction for the website course. |
| 0:51:00 | And class I can put seconds.  So I'm going to cover the details of the signal time  in the later, in the middle of the semester.  So what you repeat, pin of our reach from now.  So I always do not release the time  so that we can improve the performance.  So two of these, we need to increase those kinds of things  in class.  Program for instructions, instruction for the website  version, and the website for the second.  And let's get the first time in turn.  So we wanted to increase this program for instructions.  So I mentioned about the instruction.  So for each program, there are set of the instruction.  And we can come to the number of instructions for program.  So in the program, if there are 40 instructions, |
| 0:52:00 | then this is 40.  So you just notice the instruction count.  And we need to increase those kinds of things.  So it means that if we increase the instruction count,  then the model of fetching from the main memory  to CPU is the CPU.  And it is the number of computation of the instruction  is used.  So it is limited to decrease the number of the program,  and the number of the instruction in the program.  And this can be done by a compiler,  because a compiler can multiply it  to produce the best of these instructions.  Or you simply put two languages in the high level language. |
| 0:53:00 | So by using the kind of the high level, the group,  I agree with you.  So we can get the smaller number of the main  and the code.  So we can get the smaller number of the main instructions  for the program.  One of the important things is that it's  very important to be questioned on every type.  Can any language type can be met to their test?  And these tests will be introduced  in the number of the instructions for program.  Also, the instruction can be met to decrease those kinds  of the time.  How about instruction for cross-cyclobs?  So I mentioned about the instruction  of counting children.  In instruction for cross-cyclobs means  that we need to understand about the load |
| 0:54:00 | of the hardware, the hardware, the things in children.  So there are cross-cyclobs in the CPU.  And this CPU clock key, you can see clearly  part of the clock key here.  So it's the operation of this hardware  where we are going to buy the constant clock.  So in the CPU there is the load of the speed  and the higher the speed, the constant error.  So this clock cycle is used to pull the computation.  And then the hardware will be out.  So in this clock cycle, you can see that this top is one clock  cycle.  So from this rising machine to next large machine,  this system, the clock, the unit of the clock cycle.  So you can see the first clock cycle. |
| 0:55:00 | You can see that 30 clock cycle here.  So for each instruction, actually,  this depends on the CPU design.  But for each instruction, maybe it can  require some clock cycle, some number of clock cycle,  or do the clock cycle.  So in some of the cases, some other instruction  have this thing called clock cycle.  But if it is completely that, for each instruction,  it means what kind of clock cycle  and their hardware system.  Anyway, so the important thing is that for each instruction,  there is a number of the clock cycle here.  So the point is that this is the marty instruction.  The thinking item of the marty instruction is 2.  So thinking as much for clock cycle is 4.  So here it's 2. |
| 0:56:00 | And in this case, for the program,  it can create an average instruction.  And average clock cycle is 4.  It's 2.  So we need to increase those kinds of the top.  So this is the instruction clock cycle.  And the rest of the clock cycle is 4 or 2.  So before this is the clock cycle,  and this kind of the period of time is the clock cycle period.  Also, it's the clock cycle time.  So you'll be into the degrees.  So a times the top by automizing hardware.  So Boris R.D. Saskiniale is around 280 seconds. |
| 0:57:00 | Incheck, we have ten simple parts.  Select Excel.  Andelectron VM!  So 250 seconds for the  piano,  and to need to increase the climate,  the climate, the heavier and the  it's so just an architecture.  Okay, so, and so for your inference,  you know, so we have a couple of times  of the talk which is one of the CPU frequency.  CPU, this is the crop rate,  so you know, so you can see the  frequency frequency, this is the unit,  and to this, to calculate this wall,  we need to, we need to calculate the inverse of the  crop cycle period, crop cycle time period. |
| 0:58:00 | So that is that this is the number of  items for one thing or one thing.  So for one second, how many numbers  do you have in the cycle cycle?  This is important.  It's also one of the, you're able to,  okay, and it should be higher to increase the  performance of the CPU, meaning that, you know,  the CPU decreases the speed time period.  So you have to guess that this crop cycle  here, right, you use the CPU,  and it's a commercial cycle.  So, you can, you need to recall  a inverse thing such as the  4 number, and you know, the  5 number, this crop is, the crop rate  is one of the input of the top,  so you purchase one, you decide to purchase  about the CPU.  So, you may, so I mentioned about those |
| 0:59:00 | kinds of the 2-0 tops, and 2-0 is affected  by the hardware implementation,  and they are, this is the  architecture.  So, I mean, if you decide to, you know,  so, with the 5, the hardware implementation,  then you need to, you'll define the  this is the architecture, so,  okay, okay, okay.  So, this is the advantage of CPU time.  So, I'm sure the other, like, the  exercise that is important, so maybe I can,  you know, deal with the test,  the middle of the structure.  So, actually, now I'll speak the  text, and power trends, this is  the last topic of, yes,  the trouble here.  So, our computer means some, |
| 1:00:00 | some amount of time, amount of power.  So, how do you calculate the power?  So, power can be calculated with the  capacity load modification with the  capacity load, the scope of the  portage, and CPU frequency.  So, you can see that CPU frequency,  so I mentioned about it, so if frequency is  increased, that CPU time will be increased.  So, that is, you know,  you can decrease those kinds of  the top by, you know, increase those  kinds of the top by, you know,  optimizing our hardware.  So, for instance, you can increase  these kinds of frequency,  the thousands of times by,  twice, this is the assumption. |
| 1:01:00 | And, you know, so with the  advanced model of the technology,  the frequency can be a  content increase.  So, now this can be increased  in terms of frequency,  period.  So, well, you know, if we,  you know, increase those kinds of  CPU frequency, that the power  will increase.  And power increasing is, you know,  it's a very, you know,  increasing heat, the temperature of  the CPU so that, you know,  probably, could, could, to  utilize that, CPU can, here.  So, that is the power,  so in the technology  capacity, you know, increase the  CPU frequency, but, you know,  the power will also be increased  so much, you know, easily |
| 1:02:00 | increased the CPU frequency.  And so, then, so now, you can think  that how well you just need  a voltage from the five volts  to the one.  So, even this case, you know,  so we can decrease the power.  So, although you just increase the  power, you know, so if we compare  with the previous things, you just  decrease.  But, so we can, you know, need to  voltage from the, due to the  increase power.  So, mention that, so, we just  decrease the power, the five volts  to the volts, but, you know,  so now this, so by utilizing our  current voltage, maybe it's, we can  get the 0.8 voltage, so,  to our best.  So, we can, further, |
| 1:03:00 | reduce the voltage to, so, here,  just prepare something, exactly.  I'm sorry, I didn't even turn it too,  so, suppose that, you mean, the  CPU has 85% of the capacity  of the CPU, and the 10%  voltage, and 15% frequency  reduction.  So, what is the impact on power,  for the newly-proved sensor,  when we compare to the  work process?  So, then, this is the,  the configuration thing.  So, the answer is that, you know,  we measure that, this kind of,  you know, for many children,  and, you know, in this case, you  will decrease by 0.8  and it has decreased,  it's, you know, 16, |
| 1:04:00 | 15% of the voltage, and  10% of the frequency reduction.  So, we can, you know, we can,  let's try, this top with 0.8  to 500.  So, that now we can, again,  this conceptual attack.  Let me say phones 5.  We find the hardware.  So, we can get the Новig processor,  that uses power for the whole wprowadent  procedure.  So, then is the,  So, that is the concept of power work.  So, you see what you should do over the concept of power work.  So, not that the case of the concept, the capacity work, the vertigial or so on.  So, you don't think it's that high event the concept of power work in here.  So, to be kept up, you just work the edge forward, you just make the edge power |
| 1:05:00 | and you cannot use the more kit, you just work the edge and the complexity here.  So, you can see the discrep, you can see the clock rate, the current and the power.  So, until 2004, the clock rate and power increased and the clock rate increased,  the clock rate increased when the power.  But, after 2004, due to the power work, it's up to that end or the level of the set.  So, and because the performance increased, due to the performance of the set.  So, it's 25% or 0.  But, you know, it is constantly by power knowledge and the open memory link. |
| 1:06:00 | So, what can we do?  So, we just need the power work and the parts of the connected, you know, are working here.  So, we utilize the multiple systems here.  So, I recovered something like a free concept, free file, and my position here.  So, when you position yourself, you know, there's one sheet, there are a world position.  What if you mean, you know, what's the other one?  So, you know, one sheet, there are multiple columns.  There's a way to do that.  The parallel, they were connected to the parallel, they were connected to the instructions.  So, instead of the instruction, it's a parallel, so that it can improve the performance.  Why, you can maintain the frequency of the CPU. |
| 1:07:00 | So, it will use the four, the, what it called, what it called, processor means that the more the one sheet,  or the processor is, it is the one sheet.  And, in the case, it's basically parallel programming.  So, you know, see if you want to utilize the multiple kinds of four,  then you need to make the four, then utilize the multiple kinds of four.  And you need to synchronize in some of the pieces, of course, you know, your own program.  And some of the code should not be parallelized.  So, in the case, you know, you need to synchronize in some kinds of things.  And, by the time, so we have the set of evolution of the contact control, the GPU,  and the special course hardware.  So, these kinds of the hardware is used to, you know, |
| 1:08:00 | the competition, parallel competition, so that it can increase the performance of the competition.  So, you need to know this, that it's okay, maybe you should be fully evolved,  if you have the contact control, so it's a conclusion to the rational panel.  So, so, actually, this top, today's topic is that,  it's a kind of overview of the business.  So, we will understand a lot of the principles, about the, what is the case for,  something like the mind of things.  So, how programs are frustrated to the Washington, then, U.S., so it is, you know,  so we don't know about the process of the competition and the exclusion of the hardware.  And, we don't know about the, we really know about the instruction set of the action,  and we will know the below of the instruction set of the action.  So, how, the people, how, how, and, you know, the, you know, |
| 1:09:00 | and how this can be interpreted in the child, so it may be in more details, well.  So, we have been using, we know about the, what the time is,  the program of course, and mention that time is important.  So, why do we learn about these kinds of the stuff?  Why do we learn about the principles of the content and the action?  So, because you guys are not, you guys, not only the engineer, but you guys are scientists,  so, you know, so you want to call my therapist a scientist, so, in the case,  you need to know this is a lot of principles, and by using a principle,  you need to know the complex for a more new method, so, so, so,  so it's a pretty important, is the program that people, so, please concentrate,  or, you know, on the principles of the care, and you want to be in the software that people use, |
| 1:10:00 | or you want to, uh, purchase, purchase, is the action.  So, I know myself, I know, I have a company in mind, so,  we need to learn about the principles of the care.  So, it's somebody, so we, you know, about the abstraction in the,  uh, comfort systems, in both, hardware and software,  and, and such as our contract, we see the basically trends of the government,  and you don't know about the performance matching, which is the,  the time here, so, and we, you know, it's a lot about the power of work,  so, we, too, uh, about the power of work, which,  has a parallelism, so, with that, uh, the end of the instructions,  and then, we have to take the question, okay?  So, uh, let's finish the class, and if you have an education,  then I can come to you. |
